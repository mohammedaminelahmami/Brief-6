{"ast":null,"code":"'use strict';\n\nconst align = {\n  right: alignRight,\n  center: alignCenter\n};\nconst top = 0;\nconst right = 1;\nconst bottom = 2;\nconst left = 3;\nexport class UI {\n  constructor(opts) {\n    var _a;\n\n    this.width = opts.width;\n    this.wrap = (_a = opts.wrap) !== null && _a !== void 0 ? _a : true;\n    this.rows = [];\n  }\n\n  span() {\n    const cols = this.div(...arguments);\n    cols.span = true;\n  }\n\n  resetOutput() {\n    this.rows = [];\n  }\n\n  div() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    if (args.length === 0) {\n      this.div('');\n    }\n\n    if (this.wrap && this.shouldApplyLayoutDSL(...args) && typeof args[0] === 'string') {\n      return this.applyLayoutDSL(args[0]);\n    }\n\n    const cols = args.map(arg => {\n      if (typeof arg === 'string') {\n        return this.colFromString(arg);\n      }\n\n      return arg;\n    });\n    this.rows.push(cols);\n    return cols;\n  }\n\n  shouldApplyLayoutDSL() {\n    return arguments.length === 1 && typeof (arguments.length <= 0 ? undefined : arguments[0]) === 'string' && /[\\t\\n]/.test(arguments.length <= 0 ? undefined : arguments[0]);\n  }\n\n  applyLayoutDSL(str) {\n    const rows = str.split('\\n').map(row => row.split('\\t'));\n    let leftColumnWidth = 0; // simple heuristic for layout, make sure the\n    // second column lines up along the left-hand.\n    // don't allow the first column to take up more\n    // than 50% of the screen.\n\n    rows.forEach(columns => {\n      if (columns.length > 1 && mixin.stringWidth(columns[0]) > leftColumnWidth) {\n        leftColumnWidth = Math.min(Math.floor(this.width * 0.5), mixin.stringWidth(columns[0]));\n      }\n    }); // generate a table:\n    //  replacing ' ' with padding calculations.\n    //  using the algorithmically generated width.\n\n    rows.forEach(columns => {\n      this.div(...columns.map((r, i) => {\n        return {\n          text: r.trim(),\n          padding: this.measurePadding(r),\n          width: i === 0 && columns.length > 1 ? leftColumnWidth : undefined\n        };\n      }));\n    });\n    return this.rows[this.rows.length - 1];\n  }\n\n  colFromString(text) {\n    return {\n      text,\n      padding: this.measurePadding(text)\n    };\n  }\n\n  measurePadding(str) {\n    // measure padding without ansi escape codes\n    const noAnsi = mixin.stripAnsi(str);\n    return [0, noAnsi.match(/\\s*$/)[0].length, 0, noAnsi.match(/^\\s*/)[0].length];\n  }\n\n  toString() {\n    const lines = [];\n    this.rows.forEach(row => {\n      this.rowToString(row, lines);\n    }); // don't display any lines with the\n    // hidden flag set.\n\n    return lines.filter(line => !line.hidden).map(line => line.text).join('\\n');\n  }\n\n  rowToString(row, lines) {\n    this.rasterize(row).forEach((rrow, r) => {\n      let str = '';\n      rrow.forEach((col, c) => {\n        const {\n          width\n        } = row[c]; // the width with padding.\n\n        const wrapWidth = this.negatePadding(row[c]); // the width without padding.\n\n        let ts = col; // temporary string used during alignment/padding.\n\n        if (wrapWidth > mixin.stringWidth(col)) {\n          ts += ' '.repeat(wrapWidth - mixin.stringWidth(col));\n        } // align the string within its column.\n\n\n        if (row[c].align && row[c].align !== 'left' && this.wrap) {\n          const fn = align[row[c].align];\n          ts = fn(ts, wrapWidth);\n\n          if (mixin.stringWidth(ts) < wrapWidth) {\n            ts += ' '.repeat((width || 0) - mixin.stringWidth(ts) - 1);\n          }\n        } // apply border and padding to string.\n\n\n        const padding = row[c].padding || [0, 0, 0, 0];\n\n        if (padding[left]) {\n          str += ' '.repeat(padding[left]);\n        }\n\n        str += addBorder(row[c], ts, '| ');\n        str += ts;\n        str += addBorder(row[c], ts, ' |');\n\n        if (padding[right]) {\n          str += ' '.repeat(padding[right]);\n        } // if prior row is span, try to render the\n        // current row on the prior line.\n\n\n        if (r === 0 && lines.length > 0) {\n          str = this.renderInline(str, lines[lines.length - 1]);\n        }\n      }); // remove trailing whitespace.\n\n      lines.push({\n        text: str.replace(/ +$/, ''),\n        span: row.span\n      });\n    });\n    return lines;\n  } // if the full 'source' can render in\n  // the target line, do so.\n\n\n  renderInline(source, previousLine) {\n    const match = source.match(/^ */);\n    const leadingWhitespace = match ? match[0].length : 0;\n    const target = previousLine.text;\n    const targetTextWidth = mixin.stringWidth(target.trimRight());\n\n    if (!previousLine.span) {\n      return source;\n    } // if we're not applying wrapping logic,\n    // just always append to the span.\n\n\n    if (!this.wrap) {\n      previousLine.hidden = true;\n      return target + source;\n    }\n\n    if (leadingWhitespace < targetTextWidth) {\n      return source;\n    }\n\n    previousLine.hidden = true;\n    return target.trimRight() + ' '.repeat(leadingWhitespace - targetTextWidth) + source.trimLeft();\n  }\n\n  rasterize(row) {\n    const rrows = [];\n    const widths = this.columnWidths(row);\n    let wrapped; // word wrap all columns, and create\n    // a data-structure that is easy to rasterize.\n\n    row.forEach((col, c) => {\n      // leave room for left and right padding.\n      col.width = widths[c];\n\n      if (this.wrap) {\n        wrapped = mixin.wrap(col.text, this.negatePadding(col), {\n          hard: true\n        }).split('\\n');\n      } else {\n        wrapped = col.text.split('\\n');\n      }\n\n      if (col.border) {\n        wrapped.unshift('.' + '-'.repeat(this.negatePadding(col) + 2) + '.');\n        wrapped.push(\"'\" + '-'.repeat(this.negatePadding(col) + 2) + \"'\");\n      } // add top and bottom padding.\n\n\n      if (col.padding) {\n        wrapped.unshift(...new Array(col.padding[top] || 0).fill(''));\n        wrapped.push(...new Array(col.padding[bottom] || 0).fill(''));\n      }\n\n      wrapped.forEach((str, r) => {\n        if (!rrows[r]) {\n          rrows.push([]);\n        }\n\n        const rrow = rrows[r];\n\n        for (let i = 0; i < c; i++) {\n          if (rrow[i] === undefined) {\n            rrow.push('');\n          }\n        }\n\n        rrow.push(str);\n      });\n    });\n    return rrows;\n  }\n\n  negatePadding(col) {\n    let wrapWidth = col.width || 0;\n\n    if (col.padding) {\n      wrapWidth -= (col.padding[left] || 0) + (col.padding[right] || 0);\n    }\n\n    if (col.border) {\n      wrapWidth -= 4;\n    }\n\n    return wrapWidth;\n  }\n\n  columnWidths(row) {\n    if (!this.wrap) {\n      return row.map(col => {\n        return col.width || mixin.stringWidth(col.text);\n      });\n    }\n\n    let unset = row.length;\n    let remainingWidth = this.width; // column widths can be set in config.\n\n    const widths = row.map(col => {\n      if (col.width) {\n        unset--;\n        remainingWidth -= col.width;\n        return col.width;\n      }\n\n      return undefined;\n    }); // any unset widths should be calculated.\n\n    const unsetWidth = unset ? Math.floor(remainingWidth / unset) : 0;\n    return widths.map((w, i) => {\n      if (w === undefined) {\n        return Math.max(unsetWidth, _minWidth(row[i]));\n      }\n\n      return w;\n    });\n  }\n\n}\n\nfunction addBorder(col, ts, style) {\n  if (col.border) {\n    if (/[.']-+[.']/.test(ts)) {\n      return '';\n    }\n\n    if (ts.trim().length !== 0) {\n      return style;\n    }\n\n    return '  ';\n  }\n\n  return '';\n} // calculates the minimum width of\n// a column, based on padding preferences.\n\n\nfunction _minWidth(col) {\n  const padding = col.padding || [];\n  const minWidth = 1 + (padding[left] || 0) + (padding[right] || 0);\n\n  if (col.border) {\n    return minWidth + 4;\n  }\n\n  return minWidth;\n}\n\nfunction getWindowWidth() {\n  /* istanbul ignore next: depends on terminal */\n  if (typeof process === 'object' && process.stdout && process.stdout.columns) {\n    return process.stdout.columns;\n  }\n\n  return 80;\n}\n\nfunction alignRight(str, width) {\n  str = str.trim();\n  const strWidth = mixin.stringWidth(str);\n\n  if (strWidth < width) {\n    return ' '.repeat(width - strWidth) + str;\n  }\n\n  return str;\n}\n\nfunction alignCenter(str, width) {\n  str = str.trim();\n  const strWidth = mixin.stringWidth(str);\n  /* istanbul ignore next */\n\n  if (strWidth >= width) {\n    return str;\n  }\n\n  return ' '.repeat(width - strWidth >> 1) + str;\n}\n\nlet mixin;\nexport function cliui(opts, _mixin) {\n  mixin = _mixin;\n  return new UI({\n    width: (opts === null || opts === void 0 ? void 0 : opts.width) || getWindowWidth(),\n    wrap: opts === null || opts === void 0 ? void 0 : opts.wrap\n  });\n}","map":{"version":3,"sources":["C:/Users/YC/Desktop/brief6-frontend/node_modules/cliui/build/lib/index.js"],"names":["align","right","alignRight","center","alignCenter","top","bottom","left","UI","constructor","opts","_a","width","wrap","rows","span","cols","div","resetOutput","args","length","shouldApplyLayoutDSL","applyLayoutDSL","map","arg","colFromString","push","test","str","split","row","leftColumnWidth","forEach","columns","mixin","stringWidth","Math","min","floor","r","i","text","trim","padding","measurePadding","undefined","noAnsi","stripAnsi","match","toString","lines","rowToString","filter","line","hidden","join","rasterize","rrow","col","c","wrapWidth","negatePadding","ts","repeat","fn","addBorder","renderInline","replace","source","previousLine","leadingWhitespace","target","targetTextWidth","trimRight","trimLeft","rrows","widths","columnWidths","wrapped","hard","border","unshift","Array","fill","unset","remainingWidth","unsetWidth","w","max","_minWidth","style","minWidth","getWindowWidth","process","stdout","strWidth","cliui","_mixin"],"mappings":"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","sourcesContent":["'use strict';\nconst align = {\n    right: alignRight,\n    center: alignCenter\n};\nconst top = 0;\nconst right = 1;\nconst bottom = 2;\nconst left = 3;\nexport class UI {\n    constructor(opts) {\n        var _a;\n        this.width = opts.width;\n        this.wrap = (_a = opts.wrap) !== null && _a !== void 0 ? _a : true;\n        this.rows = [];\n    }\n    span(...args) {\n        const cols = this.div(...args);\n        cols.span = true;\n    }\n    resetOutput() {\n        this.rows = [];\n    }\n    div(...args) {\n        if (args.length === 0) {\n            this.div('');\n        }\n        if (this.wrap && this.shouldApplyLayoutDSL(...args) && typeof args[0] === 'string') {\n            return this.applyLayoutDSL(args[0]);\n        }\n        const cols = args.map(arg => {\n            if (typeof arg === 'string') {\n                return this.colFromString(arg);\n            }\n            return arg;\n        });\n        this.rows.push(cols);\n        return cols;\n    }\n    shouldApplyLayoutDSL(...args) {\n        return args.length === 1 && typeof args[0] === 'string' &&\n            /[\\t\\n]/.test(args[0]);\n    }\n    applyLayoutDSL(str) {\n        const rows = str.split('\\n').map(row => row.split('\\t'));\n        let leftColumnWidth = 0;\n        // simple heuristic for layout, make sure the\n        // second column lines up along the left-hand.\n        // don't allow the first column to take up more\n        // than 50% of the screen.\n        rows.forEach(columns => {\n            if (columns.length > 1 && mixin.stringWidth(columns[0]) > leftColumnWidth) {\n                leftColumnWidth = Math.min(Math.floor(this.width * 0.5), mixin.stringWidth(columns[0]));\n            }\n        });\n        // generate a table:\n        //  replacing ' ' with padding calculations.\n        //  using the algorithmically generated width.\n        rows.forEach(columns => {\n            this.div(...columns.map((r, i) => {\n                return {\n                    text: r.trim(),\n                    padding: this.measurePadding(r),\n                    width: (i === 0 && columns.length > 1) ? leftColumnWidth : undefined\n                };\n            }));\n        });\n        return this.rows[this.rows.length - 1];\n    }\n    colFromString(text) {\n        return {\n            text,\n            padding: this.measurePadding(text)\n        };\n    }\n    measurePadding(str) {\n        // measure padding without ansi escape codes\n        const noAnsi = mixin.stripAnsi(str);\n        return [0, noAnsi.match(/\\s*$/)[0].length, 0, noAnsi.match(/^\\s*/)[0].length];\n    }\n    toString() {\n        const lines = [];\n        this.rows.forEach(row => {\n            this.rowToString(row, lines);\n        });\n        // don't display any lines with the\n        // hidden flag set.\n        return lines\n            .filter(line => !line.hidden)\n            .map(line => line.text)\n            .join('\\n');\n    }\n    rowToString(row, lines) {\n        this.rasterize(row).forEach((rrow, r) => {\n            let str = '';\n            rrow.forEach((col, c) => {\n                const { width } = row[c]; // the width with padding.\n                const wrapWidth = this.negatePadding(row[c]); // the width without padding.\n                let ts = col; // temporary string used during alignment/padding.\n                if (wrapWidth > mixin.stringWidth(col)) {\n                    ts += ' '.repeat(wrapWidth - mixin.stringWidth(col));\n                }\n                // align the string within its column.\n                if (row[c].align && row[c].align !== 'left' && this.wrap) {\n                    const fn = align[row[c].align];\n                    ts = fn(ts, wrapWidth);\n                    if (mixin.stringWidth(ts) < wrapWidth) {\n                        ts += ' '.repeat((width || 0) - mixin.stringWidth(ts) - 1);\n                    }\n                }\n                // apply border and padding to string.\n                const padding = row[c].padding || [0, 0, 0, 0];\n                if (padding[left]) {\n                    str += ' '.repeat(padding[left]);\n                }\n                str += addBorder(row[c], ts, '| ');\n                str += ts;\n                str += addBorder(row[c], ts, ' |');\n                if (padding[right]) {\n                    str += ' '.repeat(padding[right]);\n                }\n                // if prior row is span, try to render the\n                // current row on the prior line.\n                if (r === 0 && lines.length > 0) {\n                    str = this.renderInline(str, lines[lines.length - 1]);\n                }\n            });\n            // remove trailing whitespace.\n            lines.push({\n                text: str.replace(/ +$/, ''),\n                span: row.span\n            });\n        });\n        return lines;\n    }\n    // if the full 'source' can render in\n    // the target line, do so.\n    renderInline(source, previousLine) {\n        const match = source.match(/^ */);\n        const leadingWhitespace = match ? match[0].length : 0;\n        const target = previousLine.text;\n        const targetTextWidth = mixin.stringWidth(target.trimRight());\n        if (!previousLine.span) {\n            return source;\n        }\n        // if we're not applying wrapping logic,\n        // just always append to the span.\n        if (!this.wrap) {\n            previousLine.hidden = true;\n            return target + source;\n        }\n        if (leadingWhitespace < targetTextWidth) {\n            return source;\n        }\n        previousLine.hidden = true;\n        return target.trimRight() + ' '.repeat(leadingWhitespace - targetTextWidth) + source.trimLeft();\n    }\n    rasterize(row) {\n        const rrows = [];\n        const widths = this.columnWidths(row);\n        let wrapped;\n        // word wrap all columns, and create\n        // a data-structure that is easy to rasterize.\n        row.forEach((col, c) => {\n            // leave room for left and right padding.\n            col.width = widths[c];\n            if (this.wrap) {\n                wrapped = mixin.wrap(col.text, this.negatePadding(col), { hard: true }).split('\\n');\n            }\n            else {\n                wrapped = col.text.split('\\n');\n            }\n            if (col.border) {\n                wrapped.unshift('.' + '-'.repeat(this.negatePadding(col) + 2) + '.');\n                wrapped.push(\"'\" + '-'.repeat(this.negatePadding(col) + 2) + \"'\");\n            }\n            // add top and bottom padding.\n            if (col.padding) {\n                wrapped.unshift(...new Array(col.padding[top] || 0).fill(''));\n                wrapped.push(...new Array(col.padding[bottom] || 0).fill(''));\n            }\n            wrapped.forEach((str, r) => {\n                if (!rrows[r]) {\n                    rrows.push([]);\n                }\n                const rrow = rrows[r];\n                for (let i = 0; i < c; i++) {\n                    if (rrow[i] === undefined) {\n                        rrow.push('');\n                    }\n                }\n                rrow.push(str);\n            });\n        });\n        return rrows;\n    }\n    negatePadding(col) {\n        let wrapWidth = col.width || 0;\n        if (col.padding) {\n            wrapWidth -= (col.padding[left] || 0) + (col.padding[right] || 0);\n        }\n        if (col.border) {\n            wrapWidth -= 4;\n        }\n        return wrapWidth;\n    }\n    columnWidths(row) {\n        if (!this.wrap) {\n            return row.map(col => {\n                return col.width || mixin.stringWidth(col.text);\n            });\n        }\n        let unset = row.length;\n        let remainingWidth = this.width;\n        // column widths can be set in config.\n        const widths = row.map(col => {\n            if (col.width) {\n                unset--;\n                remainingWidth -= col.width;\n                return col.width;\n            }\n            return undefined;\n        });\n        // any unset widths should be calculated.\n        const unsetWidth = unset ? Math.floor(remainingWidth / unset) : 0;\n        return widths.map((w, i) => {\n            if (w === undefined) {\n                return Math.max(unsetWidth, _minWidth(row[i]));\n            }\n            return w;\n        });\n    }\n}\nfunction addBorder(col, ts, style) {\n    if (col.border) {\n        if (/[.']-+[.']/.test(ts)) {\n            return '';\n        }\n        if (ts.trim().length !== 0) {\n            return style;\n        }\n        return '  ';\n    }\n    return '';\n}\n// calculates the minimum width of\n// a column, based on padding preferences.\nfunction _minWidth(col) {\n    const padding = col.padding || [];\n    const minWidth = 1 + (padding[left] || 0) + (padding[right] || 0);\n    if (col.border) {\n        return minWidth + 4;\n    }\n    return minWidth;\n}\nfunction getWindowWidth() {\n    /* istanbul ignore next: depends on terminal */\n    if (typeof process === 'object' && process.stdout && process.stdout.columns) {\n        return process.stdout.columns;\n    }\n    return 80;\n}\nfunction alignRight(str, width) {\n    str = str.trim();\n    const strWidth = mixin.stringWidth(str);\n    if (strWidth < width) {\n        return ' '.repeat(width - strWidth) + str;\n    }\n    return str;\n}\nfunction alignCenter(str, width) {\n    str = str.trim();\n    const strWidth = mixin.stringWidth(str);\n    /* istanbul ignore next */\n    if (strWidth >= width) {\n        return str;\n    }\n    return ' '.repeat((width - strWidth) >> 1) + str;\n}\nlet mixin;\nexport function cliui(opts, _mixin) {\n    mixin = _mixin;\n    return new UI({\n        width: (opts === null || opts === void 0 ? void 0 : opts.width) || getWindowWidth(),\n        wrap: opts === null || opts === void 0 ? void 0 : opts.wrap\n    });\n}\n"]},"metadata":{},"sourceType":"module"}