{"ast":null,"code":"import { assertNotStrictEqual } from './typings/common-types.js';\nimport { isPromise } from './utils/is-promise.js';\nimport { applyMiddleware, commandMiddlewareFactory } from './middleware.js';\nimport { parseCommand } from './parse-command.js';\nimport { isYargsInstance } from './yargs-factory.js';\nimport whichModule from './utils/which-module.js';\nconst DEFAULT_MARKER = /(^\\*)|(^\\$0)/;\nexport function command(yargs, usage, validation) {\n  let globalMiddleware = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n  let shim = arguments.length > 4 ? arguments[4] : undefined;\n  const self = {};\n  let handlers = {};\n  let aliasMap = {};\n  let defaultCommand;\n\n  self.addHandler = function addHandler(cmd, description, builder, handler, commandMiddleware, deprecated) {\n    let aliases = [];\n    const middlewares = commandMiddlewareFactory(commandMiddleware);\n\n    handler = handler || (() => {});\n\n    if (Array.isArray(cmd)) {\n      if (isCommandAndAliases(cmd)) {\n        [cmd, ...aliases] = cmd;\n      } else {\n        for (const command of cmd) {\n          self.addHandler(command);\n        }\n      }\n    } else if (isCommandHandlerDefinition(cmd)) {\n      let command = Array.isArray(cmd.command) || typeof cmd.command === 'string' ? cmd.command : moduleName(cmd);\n      if (cmd.aliases) command = [].concat(command).concat(cmd.aliases);\n      self.addHandler(command, extractDesc(cmd), cmd.builder, cmd.handler, cmd.middlewares, cmd.deprecated);\n      return;\n    } else if (isCommandBuilderDefinition(builder)) {\n      self.addHandler([cmd].concat(aliases), description, builder.builder, builder.handler, builder.middlewares, builder.deprecated);\n      return;\n    }\n\n    if (typeof cmd === 'string') {\n      const parsedCommand = parseCommand(cmd);\n      aliases = aliases.map(alias => parseCommand(alias).cmd);\n      let isDefault = false;\n      const parsedAliases = [parsedCommand.cmd].concat(aliases).filter(c => {\n        if (DEFAULT_MARKER.test(c)) {\n          isDefault = true;\n          return false;\n        }\n\n        return true;\n      });\n      if (parsedAliases.length === 0 && isDefault) parsedAliases.push('$0');\n\n      if (isDefault) {\n        parsedCommand.cmd = parsedAliases[0];\n        aliases = parsedAliases.slice(1);\n        cmd = cmd.replace(DEFAULT_MARKER, parsedCommand.cmd);\n      }\n\n      aliases.forEach(alias => {\n        aliasMap[alias] = parsedCommand.cmd;\n      });\n\n      if (description !== false) {\n        usage.command(cmd, description, isDefault, aliases, deprecated);\n      }\n\n      handlers[parsedCommand.cmd] = {\n        original: cmd,\n        description,\n        handler,\n        builder: builder || {},\n        middlewares,\n        deprecated,\n        demanded: parsedCommand.demanded,\n        optional: parsedCommand.optional\n      };\n      if (isDefault) defaultCommand = handlers[parsedCommand.cmd];\n    }\n  };\n\n  self.addDirectory = function addDirectory(dir, context, req, callerFile, opts) {\n    opts = opts || {};\n    if (typeof opts.recurse !== 'boolean') opts.recurse = false;\n    if (!Array.isArray(opts.extensions)) opts.extensions = ['js'];\n    const parentVisit = typeof opts.visit === 'function' ? opts.visit : o => o;\n\n    opts.visit = function visit(obj, joined, filename) {\n      const visited = parentVisit(obj, joined, filename);\n\n      if (visited) {\n        if (~context.files.indexOf(joined)) return visited;\n        context.files.push(joined);\n        self.addHandler(visited);\n      }\n\n      return visited;\n    };\n\n    shim.requireDirectory({\n      require: req,\n      filename: callerFile\n    }, dir, opts);\n  };\n\n  function moduleName(obj) {\n    const mod = whichModule(obj);\n    if (!mod) throw new Error(`No command name given for module: ${shim.inspect(obj)}`);\n    return commandFromFilename(mod.filename);\n  }\n\n  function commandFromFilename(filename) {\n    return shim.path.basename(filename, shim.path.extname(filename));\n  }\n\n  function extractDesc(_ref) {\n    let {\n      describe,\n      description,\n      desc\n    } = _ref;\n\n    for (const test of [describe, description, desc]) {\n      if (typeof test === 'string' || test === false) return test;\n      assertNotStrictEqual(test, true, shim);\n    }\n\n    return false;\n  }\n\n  self.getCommands = () => Object.keys(handlers).concat(Object.keys(aliasMap));\n\n  self.getCommandHandlers = () => handlers;\n\n  self.hasDefaultCommand = () => !!defaultCommand;\n\n  self.runCommand = function runCommand(command, yargs, parsed, commandIndex) {\n    let aliases = parsed.aliases;\n    const commandHandler = handlers[command] || handlers[aliasMap[command]] || defaultCommand;\n    const currentContext = yargs.getContext();\n    let numFiles = currentContext.files.length;\n    const parentCommands = currentContext.commands.slice();\n    let innerArgv = parsed.argv;\n    let positionalMap = {};\n\n    if (command) {\n      currentContext.commands.push(command);\n      currentContext.fullCommands.push(commandHandler.original);\n    }\n\n    const builder = commandHandler.builder;\n\n    if (isCommandBuilderCallback(builder)) {\n      const builderOutput = builder(yargs.reset(parsed.aliases));\n      const innerYargs = isYargsInstance(builderOutput) ? builderOutput : yargs;\n\n      if (shouldUpdateUsage(innerYargs)) {\n        innerYargs.getUsageInstance().usage(usageFromParentCommandsCommandHandler(parentCommands, commandHandler), commandHandler.description);\n      }\n\n      innerArgv = innerYargs._parseArgs(null, null, true, commandIndex);\n      aliases = innerYargs.parsed.aliases;\n    } else if (isCommandBuilderOptionDefinitions(builder)) {\n      const innerYargs = yargs.reset(parsed.aliases);\n\n      if (shouldUpdateUsage(innerYargs)) {\n        innerYargs.getUsageInstance().usage(usageFromParentCommandsCommandHandler(parentCommands, commandHandler), commandHandler.description);\n      }\n\n      Object.keys(commandHandler.builder).forEach(key => {\n        innerYargs.option(key, builder[key]);\n      });\n      innerArgv = innerYargs._parseArgs(null, null, true, commandIndex);\n      aliases = innerYargs.parsed.aliases;\n    }\n\n    if (!yargs._hasOutput()) {\n      positionalMap = populatePositionals(commandHandler, innerArgv, currentContext);\n    }\n\n    const middlewares = globalMiddleware.slice(0).concat(commandHandler.middlewares);\n    applyMiddleware(innerArgv, yargs, middlewares, true);\n\n    if (!yargs._hasOutput()) {\n      yargs._runValidation(innerArgv, aliases, positionalMap, yargs.parsed.error, !command);\n    }\n\n    if (commandHandler.handler && !yargs._hasOutput()) {\n      yargs._setHasOutput();\n\n      const populateDoubleDash = !!yargs.getOptions().configuration['populate--'];\n\n      yargs._postProcess(innerArgv, populateDoubleDash);\n\n      innerArgv = applyMiddleware(innerArgv, yargs, middlewares, false);\n      let handlerResult;\n\n      if (isPromise(innerArgv)) {\n        handlerResult = innerArgv.then(argv => commandHandler.handler(argv));\n      } else {\n        handlerResult = commandHandler.handler(innerArgv);\n      }\n\n      const handlerFinishCommand = yargs.getHandlerFinishCommand();\n\n      if (isPromise(handlerResult)) {\n        yargs.getUsageInstance().cacheHelpMessage();\n        handlerResult.then(value => {\n          if (handlerFinishCommand) {\n            handlerFinishCommand(value);\n          }\n        }).catch(error => {\n          try {\n            yargs.getUsageInstance().fail(null, error);\n          } catch (err) {}\n        }).then(() => {\n          yargs.getUsageInstance().clearCachedHelpMessage();\n        });\n      } else {\n        if (handlerFinishCommand) {\n          handlerFinishCommand(handlerResult);\n        }\n      }\n    }\n\n    if (command) {\n      currentContext.commands.pop();\n      currentContext.fullCommands.pop();\n    }\n\n    numFiles = currentContext.files.length - numFiles;\n    if (numFiles > 0) currentContext.files.splice(numFiles * -1, numFiles);\n    return innerArgv;\n  };\n\n  function shouldUpdateUsage(yargs) {\n    return !yargs.getUsageInstance().getUsageDisabled() && yargs.getUsageInstance().getUsage().length === 0;\n  }\n\n  function usageFromParentCommandsCommandHandler(parentCommands, commandHandler) {\n    const c = DEFAULT_MARKER.test(commandHandler.original) ? commandHandler.original.replace(DEFAULT_MARKER, '').trim() : commandHandler.original;\n    const pc = parentCommands.filter(c => {\n      return !DEFAULT_MARKER.test(c);\n    });\n    pc.push(c);\n    return `$0 ${pc.join(' ')}`;\n  }\n\n  self.runDefaultBuilderOn = function (yargs) {\n    assertNotStrictEqual(defaultCommand, undefined, shim);\n\n    if (shouldUpdateUsage(yargs)) {\n      const commandString = DEFAULT_MARKER.test(defaultCommand.original) ? defaultCommand.original : defaultCommand.original.replace(/^[^[\\]<>]*/, '$0 ');\n      yargs.getUsageInstance().usage(commandString, defaultCommand.description);\n    }\n\n    const builder = defaultCommand.builder;\n\n    if (isCommandBuilderCallback(builder)) {\n      builder(yargs);\n    } else if (!isCommandBuilderDefinition(builder)) {\n      Object.keys(builder).forEach(key => {\n        yargs.option(key, builder[key]);\n      });\n    }\n  };\n\n  function populatePositionals(commandHandler, argv, context) {\n    argv._ = argv._.slice(context.commands.length);\n    const demanded = commandHandler.demanded.slice(0);\n    const optional = commandHandler.optional.slice(0);\n    const positionalMap = {};\n    validation.positionalCount(demanded.length, argv._.length);\n\n    while (demanded.length) {\n      const demand = demanded.shift();\n      populatePositional(demand, argv, positionalMap);\n    }\n\n    while (optional.length) {\n      const maybe = optional.shift();\n      populatePositional(maybe, argv, positionalMap);\n    }\n\n    argv._ = context.commands.concat(argv._.map(a => '' + a));\n    postProcessPositionals(argv, positionalMap, self.cmdToParseOptions(commandHandler.original));\n    return positionalMap;\n  }\n\n  function populatePositional(positional, argv, positionalMap) {\n    const cmd = positional.cmd[0];\n\n    if (positional.variadic) {\n      positionalMap[cmd] = argv._.splice(0).map(String);\n    } else {\n      if (argv._.length) positionalMap[cmd] = [String(argv._.shift())];\n    }\n  }\n\n  function postProcessPositionals(argv, positionalMap, parseOptions) {\n    const options = Object.assign({}, yargs.getOptions());\n    options.default = Object.assign(parseOptions.default, options.default);\n\n    for (const key of Object.keys(parseOptions.alias)) {\n      options.alias[key] = (options.alias[key] || []).concat(parseOptions.alias[key]);\n    }\n\n    options.array = options.array.concat(parseOptions.array);\n    options.config = {};\n    const unparsed = [];\n    Object.keys(positionalMap).forEach(key => {\n      positionalMap[key].map(value => {\n        if (options.configuration['unknown-options-as-args']) options.key[key] = true;\n        unparsed.push(`--${key}`);\n        unparsed.push(value);\n      });\n    });\n    if (!unparsed.length) return;\n    const config = Object.assign({}, options.configuration, {\n      'populate--': true\n    });\n    const parsed = shim.Parser.detailed(unparsed, Object.assign({}, options, {\n      configuration: config\n    }));\n\n    if (parsed.error) {\n      yargs.getUsageInstance().fail(parsed.error.message, parsed.error);\n    } else {\n      const positionalKeys = Object.keys(positionalMap);\n      Object.keys(positionalMap).forEach(key => {\n        positionalKeys.push(...parsed.aliases[key]);\n      });\n      Object.keys(parsed.argv).forEach(key => {\n        if (positionalKeys.indexOf(key) !== -1) {\n          if (!positionalMap[key]) positionalMap[key] = parsed.argv[key];\n          argv[key] = parsed.argv[key];\n        }\n      });\n    }\n  }\n\n  self.cmdToParseOptions = function (cmdString) {\n    const parseOptions = {\n      array: [],\n      default: {},\n      alias: {},\n      demand: {}\n    };\n    const parsed = parseCommand(cmdString);\n    parsed.demanded.forEach(d => {\n      const [cmd, ...aliases] = d.cmd;\n\n      if (d.variadic) {\n        parseOptions.array.push(cmd);\n        parseOptions.default[cmd] = [];\n      }\n\n      parseOptions.alias[cmd] = aliases;\n      parseOptions.demand[cmd] = true;\n    });\n    parsed.optional.forEach(o => {\n      const [cmd, ...aliases] = o.cmd;\n\n      if (o.variadic) {\n        parseOptions.array.push(cmd);\n        parseOptions.default[cmd] = [];\n      }\n\n      parseOptions.alias[cmd] = aliases;\n    });\n    return parseOptions;\n  };\n\n  self.reset = () => {\n    handlers = {};\n    aliasMap = {};\n    defaultCommand = undefined;\n    return self;\n  };\n\n  const frozens = [];\n\n  self.freeze = () => {\n    frozens.push({\n      handlers,\n      aliasMap,\n      defaultCommand\n    });\n  };\n\n  self.unfreeze = () => {\n    const frozen = frozens.pop();\n    assertNotStrictEqual(frozen, undefined, shim);\n    ({\n      handlers,\n      aliasMap,\n      defaultCommand\n    } = frozen);\n  };\n\n  return self;\n}\nexport function isCommandBuilderDefinition(builder) {\n  return typeof builder === 'object' && !!builder.builder && typeof builder.handler === 'function';\n}\n\nfunction isCommandAndAliases(cmd) {\n  if (cmd.every(c => typeof c === 'string')) {\n    return true;\n  } else {\n    return false;\n  }\n}\n\nexport function isCommandBuilderCallback(builder) {\n  return typeof builder === 'function';\n}\n\nfunction isCommandBuilderOptionDefinitions(builder) {\n  return typeof builder === 'object';\n}\n\nexport function isCommandHandlerDefinition(cmd) {\n  return typeof cmd === 'object' && !Array.isArray(cmd);\n}","map":{"version":3,"sources":["C:/Users/YC/Desktop/brief6-frontend/node_modules/yargs/build/lib/command.js"],"names":["assertNotStrictEqual","isPromise","applyMiddleware","commandMiddlewareFactory","parseCommand","isYargsInstance","whichModule","DEFAULT_MARKER","command","yargs","usage","validation","globalMiddleware","shim","self","handlers","aliasMap","defaultCommand","addHandler","cmd","description","builder","handler","commandMiddleware","deprecated","aliases","middlewares","Array","isArray","isCommandAndAliases","isCommandHandlerDefinition","moduleName","concat","extractDesc","isCommandBuilderDefinition","parsedCommand","map","alias","isDefault","parsedAliases","filter","c","test","length","push","slice","replace","forEach","original","demanded","optional","addDirectory","dir","context","req","callerFile","opts","recurse","extensions","parentVisit","visit","o","obj","joined","filename","visited","files","indexOf","requireDirectory","require","mod","Error","inspect","commandFromFilename","path","basename","extname","describe","desc","getCommands","Object","keys","getCommandHandlers","hasDefaultCommand","runCommand","parsed","commandIndex","commandHandler","currentContext","getContext","numFiles","parentCommands","commands","innerArgv","argv","positionalMap","fullCommands","isCommandBuilderCallback","builderOutput","reset","innerYargs","shouldUpdateUsage","getUsageInstance","usageFromParentCommandsCommandHandler","_parseArgs","isCommandBuilderOptionDefinitions","key","option","_hasOutput","populatePositionals","_runValidation","error","_setHasOutput","populateDoubleDash","getOptions","configuration","_postProcess","handlerResult","then","handlerFinishCommand","getHandlerFinishCommand","cacheHelpMessage","value","catch","fail","err","clearCachedHelpMessage","pop","splice","getUsageDisabled","getUsage","trim","pc","join","runDefaultBuilderOn","undefined","commandString","_","positionalCount","demand","shift","populatePositional","maybe","a","postProcessPositionals","cmdToParseOptions","positional","variadic","String","parseOptions","options","assign","default","array","config","unparsed","Parser","detailed","message","positionalKeys","cmdString","d","frozens","freeze","unfreeze","frozen","every"],"mappings":"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","sourcesContent":["import { assertNotStrictEqual, } from './typings/common-types.js';\nimport { isPromise } from './utils/is-promise.js';\nimport { applyMiddleware, commandMiddlewareFactory, } from './middleware.js';\nimport { parseCommand } from './parse-command.js';\nimport { isYargsInstance, } from './yargs-factory.js';\nimport whichModule from './utils/which-module.js';\nconst DEFAULT_MARKER = /(^\\*)|(^\\$0)/;\nexport function command(yargs, usage, validation, globalMiddleware = [], shim) {\n    const self = {};\n    let handlers = {};\n    let aliasMap = {};\n    let defaultCommand;\n    self.addHandler = function addHandler(cmd, description, builder, handler, commandMiddleware, deprecated) {\n        let aliases = [];\n        const middlewares = commandMiddlewareFactory(commandMiddleware);\n        handler = handler || (() => { });\n        if (Array.isArray(cmd)) {\n            if (isCommandAndAliases(cmd)) {\n                [cmd, ...aliases] = cmd;\n            }\n            else {\n                for (const command of cmd) {\n                    self.addHandler(command);\n                }\n            }\n        }\n        else if (isCommandHandlerDefinition(cmd)) {\n            let command = Array.isArray(cmd.command) || typeof cmd.command === 'string'\n                ? cmd.command\n                : moduleName(cmd);\n            if (cmd.aliases)\n                command = [].concat(command).concat(cmd.aliases);\n            self.addHandler(command, extractDesc(cmd), cmd.builder, cmd.handler, cmd.middlewares, cmd.deprecated);\n            return;\n        }\n        else if (isCommandBuilderDefinition(builder)) {\n            self.addHandler([cmd].concat(aliases), description, builder.builder, builder.handler, builder.middlewares, builder.deprecated);\n            return;\n        }\n        if (typeof cmd === 'string') {\n            const parsedCommand = parseCommand(cmd);\n            aliases = aliases.map(alias => parseCommand(alias).cmd);\n            let isDefault = false;\n            const parsedAliases = [parsedCommand.cmd].concat(aliases).filter(c => {\n                if (DEFAULT_MARKER.test(c)) {\n                    isDefault = true;\n                    return false;\n                }\n                return true;\n            });\n            if (parsedAliases.length === 0 && isDefault)\n                parsedAliases.push('$0');\n            if (isDefault) {\n                parsedCommand.cmd = parsedAliases[0];\n                aliases = parsedAliases.slice(1);\n                cmd = cmd.replace(DEFAULT_MARKER, parsedCommand.cmd);\n            }\n            aliases.forEach(alias => {\n                aliasMap[alias] = parsedCommand.cmd;\n            });\n            if (description !== false) {\n                usage.command(cmd, description, isDefault, aliases, deprecated);\n            }\n            handlers[parsedCommand.cmd] = {\n                original: cmd,\n                description,\n                handler,\n                builder: builder || {},\n                middlewares,\n                deprecated,\n                demanded: parsedCommand.demanded,\n                optional: parsedCommand.optional,\n            };\n            if (isDefault)\n                defaultCommand = handlers[parsedCommand.cmd];\n        }\n    };\n    self.addDirectory = function addDirectory(dir, context, req, callerFile, opts) {\n        opts = opts || {};\n        if (typeof opts.recurse !== 'boolean')\n            opts.recurse = false;\n        if (!Array.isArray(opts.extensions))\n            opts.extensions = ['js'];\n        const parentVisit = typeof opts.visit === 'function' ? opts.visit : (o) => o;\n        opts.visit = function visit(obj, joined, filename) {\n            const visited = parentVisit(obj, joined, filename);\n            if (visited) {\n                if (~context.files.indexOf(joined))\n                    return visited;\n                context.files.push(joined);\n                self.addHandler(visited);\n            }\n            return visited;\n        };\n        shim.requireDirectory({ require: req, filename: callerFile }, dir, opts);\n    };\n    function moduleName(obj) {\n        const mod = whichModule(obj);\n        if (!mod)\n            throw new Error(`No command name given for module: ${shim.inspect(obj)}`);\n        return commandFromFilename(mod.filename);\n    }\n    function commandFromFilename(filename) {\n        return shim.path.basename(filename, shim.path.extname(filename));\n    }\n    function extractDesc({ describe, description, desc, }) {\n        for (const test of [describe, description, desc]) {\n            if (typeof test === 'string' || test === false)\n                return test;\n            assertNotStrictEqual(test, true, shim);\n        }\n        return false;\n    }\n    self.getCommands = () => Object.keys(handlers).concat(Object.keys(aliasMap));\n    self.getCommandHandlers = () => handlers;\n    self.hasDefaultCommand = () => !!defaultCommand;\n    self.runCommand = function runCommand(command, yargs, parsed, commandIndex) {\n        let aliases = parsed.aliases;\n        const commandHandler = handlers[command] || handlers[aliasMap[command]] || defaultCommand;\n        const currentContext = yargs.getContext();\n        let numFiles = currentContext.files.length;\n        const parentCommands = currentContext.commands.slice();\n        let innerArgv = parsed.argv;\n        let positionalMap = {};\n        if (command) {\n            currentContext.commands.push(command);\n            currentContext.fullCommands.push(commandHandler.original);\n        }\n        const builder = commandHandler.builder;\n        if (isCommandBuilderCallback(builder)) {\n            const builderOutput = builder(yargs.reset(parsed.aliases));\n            const innerYargs = isYargsInstance(builderOutput) ? builderOutput : yargs;\n            if (shouldUpdateUsage(innerYargs)) {\n                innerYargs\n                    .getUsageInstance()\n                    .usage(usageFromParentCommandsCommandHandler(parentCommands, commandHandler), commandHandler.description);\n            }\n            innerArgv = innerYargs._parseArgs(null, null, true, commandIndex);\n            aliases = innerYargs.parsed.aliases;\n        }\n        else if (isCommandBuilderOptionDefinitions(builder)) {\n            const innerYargs = yargs.reset(parsed.aliases);\n            if (shouldUpdateUsage(innerYargs)) {\n                innerYargs\n                    .getUsageInstance()\n                    .usage(usageFromParentCommandsCommandHandler(parentCommands, commandHandler), commandHandler.description);\n            }\n            Object.keys(commandHandler.builder).forEach(key => {\n                innerYargs.option(key, builder[key]);\n            });\n            innerArgv = innerYargs._parseArgs(null, null, true, commandIndex);\n            aliases = innerYargs.parsed.aliases;\n        }\n        if (!yargs._hasOutput()) {\n            positionalMap = populatePositionals(commandHandler, innerArgv, currentContext);\n        }\n        const middlewares = globalMiddleware\n            .slice(0)\n            .concat(commandHandler.middlewares);\n        applyMiddleware(innerArgv, yargs, middlewares, true);\n        if (!yargs._hasOutput()) {\n            yargs._runValidation(innerArgv, aliases, positionalMap, yargs.parsed.error, !command);\n        }\n        if (commandHandler.handler && !yargs._hasOutput()) {\n            yargs._setHasOutput();\n            const populateDoubleDash = !!yargs.getOptions().configuration['populate--'];\n            yargs._postProcess(innerArgv, populateDoubleDash);\n            innerArgv = applyMiddleware(innerArgv, yargs, middlewares, false);\n            let handlerResult;\n            if (isPromise(innerArgv)) {\n                handlerResult = innerArgv.then(argv => commandHandler.handler(argv));\n            }\n            else {\n                handlerResult = commandHandler.handler(innerArgv);\n            }\n            const handlerFinishCommand = yargs.getHandlerFinishCommand();\n            if (isPromise(handlerResult)) {\n                yargs.getUsageInstance().cacheHelpMessage();\n                handlerResult\n                    .then(value => {\n                    if (handlerFinishCommand) {\n                        handlerFinishCommand(value);\n                    }\n                })\n                    .catch(error => {\n                    try {\n                        yargs.getUsageInstance().fail(null, error);\n                    }\n                    catch (err) {\n                    }\n                })\n                    .then(() => {\n                    yargs.getUsageInstance().clearCachedHelpMessage();\n                });\n            }\n            else {\n                if (handlerFinishCommand) {\n                    handlerFinishCommand(handlerResult);\n                }\n            }\n        }\n        if (command) {\n            currentContext.commands.pop();\n            currentContext.fullCommands.pop();\n        }\n        numFiles = currentContext.files.length - numFiles;\n        if (numFiles > 0)\n            currentContext.files.splice(numFiles * -1, numFiles);\n        return innerArgv;\n    };\n    function shouldUpdateUsage(yargs) {\n        return (!yargs.getUsageInstance().getUsageDisabled() &&\n            yargs.getUsageInstance().getUsage().length === 0);\n    }\n    function usageFromParentCommandsCommandHandler(parentCommands, commandHandler) {\n        const c = DEFAULT_MARKER.test(commandHandler.original)\n            ? commandHandler.original.replace(DEFAULT_MARKER, '').trim()\n            : commandHandler.original;\n        const pc = parentCommands.filter(c => {\n            return !DEFAULT_MARKER.test(c);\n        });\n        pc.push(c);\n        return `$0 ${pc.join(' ')}`;\n    }\n    self.runDefaultBuilderOn = function (yargs) {\n        assertNotStrictEqual(defaultCommand, undefined, shim);\n        if (shouldUpdateUsage(yargs)) {\n            const commandString = DEFAULT_MARKER.test(defaultCommand.original)\n                ? defaultCommand.original\n                : defaultCommand.original.replace(/^[^[\\]<>]*/, '$0 ');\n            yargs.getUsageInstance().usage(commandString, defaultCommand.description);\n        }\n        const builder = defaultCommand.builder;\n        if (isCommandBuilderCallback(builder)) {\n            builder(yargs);\n        }\n        else if (!isCommandBuilderDefinition(builder)) {\n            Object.keys(builder).forEach(key => {\n                yargs.option(key, builder[key]);\n            });\n        }\n    };\n    function populatePositionals(commandHandler, argv, context) {\n        argv._ = argv._.slice(context.commands.length);\n        const demanded = commandHandler.demanded.slice(0);\n        const optional = commandHandler.optional.slice(0);\n        const positionalMap = {};\n        validation.positionalCount(demanded.length, argv._.length);\n        while (demanded.length) {\n            const demand = demanded.shift();\n            populatePositional(demand, argv, positionalMap);\n        }\n        while (optional.length) {\n            const maybe = optional.shift();\n            populatePositional(maybe, argv, positionalMap);\n        }\n        argv._ = context.commands.concat(argv._.map(a => '' + a));\n        postProcessPositionals(argv, positionalMap, self.cmdToParseOptions(commandHandler.original));\n        return positionalMap;\n    }\n    function populatePositional(positional, argv, positionalMap) {\n        const cmd = positional.cmd[0];\n        if (positional.variadic) {\n            positionalMap[cmd] = argv._.splice(0).map(String);\n        }\n        else {\n            if (argv._.length)\n                positionalMap[cmd] = [String(argv._.shift())];\n        }\n    }\n    function postProcessPositionals(argv, positionalMap, parseOptions) {\n        const options = Object.assign({}, yargs.getOptions());\n        options.default = Object.assign(parseOptions.default, options.default);\n        for (const key of Object.keys(parseOptions.alias)) {\n            options.alias[key] = (options.alias[key] || []).concat(parseOptions.alias[key]);\n        }\n        options.array = options.array.concat(parseOptions.array);\n        options.config = {};\n        const unparsed = [];\n        Object.keys(positionalMap).forEach(key => {\n            positionalMap[key].map(value => {\n                if (options.configuration['unknown-options-as-args'])\n                    options.key[key] = true;\n                unparsed.push(`--${key}`);\n                unparsed.push(value);\n            });\n        });\n        if (!unparsed.length)\n            return;\n        const config = Object.assign({}, options.configuration, {\n            'populate--': true,\n        });\n        const parsed = shim.Parser.detailed(unparsed, Object.assign({}, options, {\n            configuration: config,\n        }));\n        if (parsed.error) {\n            yargs.getUsageInstance().fail(parsed.error.message, parsed.error);\n        }\n        else {\n            const positionalKeys = Object.keys(positionalMap);\n            Object.keys(positionalMap).forEach(key => {\n                positionalKeys.push(...parsed.aliases[key]);\n            });\n            Object.keys(parsed.argv).forEach(key => {\n                if (positionalKeys.indexOf(key) !== -1) {\n                    if (!positionalMap[key])\n                        positionalMap[key] = parsed.argv[key];\n                    argv[key] = parsed.argv[key];\n                }\n            });\n        }\n    }\n    self.cmdToParseOptions = function (cmdString) {\n        const parseOptions = {\n            array: [],\n            default: {},\n            alias: {},\n            demand: {},\n        };\n        const parsed = parseCommand(cmdString);\n        parsed.demanded.forEach(d => {\n            const [cmd, ...aliases] = d.cmd;\n            if (d.variadic) {\n                parseOptions.array.push(cmd);\n                parseOptions.default[cmd] = [];\n            }\n            parseOptions.alias[cmd] = aliases;\n            parseOptions.demand[cmd] = true;\n        });\n        parsed.optional.forEach(o => {\n            const [cmd, ...aliases] = o.cmd;\n            if (o.variadic) {\n                parseOptions.array.push(cmd);\n                parseOptions.default[cmd] = [];\n            }\n            parseOptions.alias[cmd] = aliases;\n        });\n        return parseOptions;\n    };\n    self.reset = () => {\n        handlers = {};\n        aliasMap = {};\n        defaultCommand = undefined;\n        return self;\n    };\n    const frozens = [];\n    self.freeze = () => {\n        frozens.push({\n            handlers,\n            aliasMap,\n            defaultCommand,\n        });\n    };\n    self.unfreeze = () => {\n        const frozen = frozens.pop();\n        assertNotStrictEqual(frozen, undefined, shim);\n        ({ handlers, aliasMap, defaultCommand } = frozen);\n    };\n    return self;\n}\nexport function isCommandBuilderDefinition(builder) {\n    return (typeof builder === 'object' &&\n        !!builder.builder &&\n        typeof builder.handler === 'function');\n}\nfunction isCommandAndAliases(cmd) {\n    if (cmd.every(c => typeof c === 'string')) {\n        return true;\n    }\n    else {\n        return false;\n    }\n}\nexport function isCommandBuilderCallback(builder) {\n    return typeof builder === 'function';\n}\nfunction isCommandBuilderOptionDefinitions(builder) {\n    return typeof builder === 'object';\n}\nexport function isCommandHandlerDefinition(cmd) {\n    return typeof cmd === 'object' && !Array.isArray(cmd);\n}\n"]},"metadata":{},"sourceType":"module"}