{"ast":null,"code":"import { argsert } from './argsert.js';\nimport { assertNotStrictEqual } from './typings/common-types.js';\nimport { levenshtein as distance } from './utils/levenshtein.js';\nimport { objFilter } from './utils/obj-filter.js';\nconst specialKeys = ['$0', '--', '_'];\nexport function validation(yargs, usage, y18n, shim) {\n  const __ = y18n.__;\n  const __n = y18n.__n;\n  const self = {};\n\n  self.nonOptionCount = function nonOptionCount(argv) {\n    const demandedCommands = yargs.getDemandedCommands();\n    const positionalCount = argv._.length + (argv['--'] ? argv['--'].length : 0);\n\n    const _s = positionalCount - yargs.getContext().commands.length;\n\n    if (demandedCommands._ && (_s < demandedCommands._.min || _s > demandedCommands._.max)) {\n      if (_s < demandedCommands._.min) {\n        if (demandedCommands._.minMsg !== undefined) {\n          usage.fail(demandedCommands._.minMsg ? demandedCommands._.minMsg.replace(/\\$0/g, _s.toString()).replace(/\\$1/, demandedCommands._.min.toString()) : null);\n        } else {\n          usage.fail(__n('Not enough non-option arguments: got %s, need at least %s', 'Not enough non-option arguments: got %s, need at least %s', _s, _s.toString(), demandedCommands._.min.toString()));\n        }\n      } else if (_s > demandedCommands._.max) {\n        if (demandedCommands._.maxMsg !== undefined) {\n          usage.fail(demandedCommands._.maxMsg ? demandedCommands._.maxMsg.replace(/\\$0/g, _s.toString()).replace(/\\$1/, demandedCommands._.max.toString()) : null);\n        } else {\n          usage.fail(__n('Too many non-option arguments: got %s, maximum of %s', 'Too many non-option arguments: got %s, maximum of %s', _s, _s.toString(), demandedCommands._.max.toString()));\n        }\n      }\n    }\n  };\n\n  self.positionalCount = function positionalCount(required, observed) {\n    if (observed < required) {\n      usage.fail(__n('Not enough non-option arguments: got %s, need at least %s', 'Not enough non-option arguments: got %s, need at least %s', observed, observed + '', required + ''));\n    }\n  };\n\n  self.requiredArguments = function requiredArguments(argv) {\n    const demandedOptions = yargs.getDemandedOptions();\n    let missing = null;\n\n    for (const key of Object.keys(demandedOptions)) {\n      if (!Object.prototype.hasOwnProperty.call(argv, key) || typeof argv[key] === 'undefined') {\n        missing = missing || {};\n        missing[key] = demandedOptions[key];\n      }\n    }\n\n    if (missing) {\n      const customMsgs = [];\n\n      for (const key of Object.keys(missing)) {\n        const msg = missing[key];\n\n        if (msg && customMsgs.indexOf(msg) < 0) {\n          customMsgs.push(msg);\n        }\n      }\n\n      const customMsg = customMsgs.length ? `\\n${customMsgs.join('\\n')}` : '';\n      usage.fail(__n('Missing required argument: %s', 'Missing required arguments: %s', Object.keys(missing).length, Object.keys(missing).join(', ') + customMsg));\n    }\n  };\n\n  self.unknownArguments = function unknownArguments(argv, aliases, positionalMap, isDefaultCommand) {\n    let checkPositionals = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n    const commandKeys = yargs.getCommandInstance().getCommands();\n    const unknown = [];\n    const currentContext = yargs.getContext();\n    Object.keys(argv).forEach(key => {\n      if (specialKeys.indexOf(key) === -1 && !Object.prototype.hasOwnProperty.call(positionalMap, key) && !Object.prototype.hasOwnProperty.call(yargs._getParseContext(), key) && !self.isValidAndSomeAliasIsNotNew(key, aliases)) {\n        unknown.push(key);\n      }\n    });\n\n    if (checkPositionals && (currentContext.commands.length > 0 || commandKeys.length > 0 || isDefaultCommand)) {\n      argv._.slice(currentContext.commands.length).forEach(key => {\n        if (commandKeys.indexOf('' + key) === -1) {\n          unknown.push('' + key);\n        }\n      });\n    }\n\n    if (unknown.length > 0) {\n      usage.fail(__n('Unknown argument: %s', 'Unknown arguments: %s', unknown.length, unknown.join(', ')));\n    }\n  };\n\n  self.unknownCommands = function unknownCommands(argv) {\n    const commandKeys = yargs.getCommandInstance().getCommands();\n    const unknown = [];\n    const currentContext = yargs.getContext();\n\n    if (currentContext.commands.length > 0 || commandKeys.length > 0) {\n      argv._.slice(currentContext.commands.length).forEach(key => {\n        if (commandKeys.indexOf('' + key) === -1) {\n          unknown.push('' + key);\n        }\n      });\n    }\n\n    if (unknown.length > 0) {\n      usage.fail(__n('Unknown command: %s', 'Unknown commands: %s', unknown.length, unknown.join(', ')));\n      return true;\n    } else {\n      return false;\n    }\n  };\n\n  self.isValidAndSomeAliasIsNotNew = function isValidAndSomeAliasIsNotNew(key, aliases) {\n    if (!Object.prototype.hasOwnProperty.call(aliases, key)) {\n      return false;\n    }\n\n    const newAliases = yargs.parsed.newAliases;\n\n    for (const a of [key, ...aliases[key]]) {\n      if (!Object.prototype.hasOwnProperty.call(newAliases, a) || !newAliases[key]) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  self.limitedChoices = function limitedChoices(argv) {\n    const options = yargs.getOptions();\n    const invalid = {};\n    if (!Object.keys(options.choices).length) return;\n    Object.keys(argv).forEach(key => {\n      if (specialKeys.indexOf(key) === -1 && Object.prototype.hasOwnProperty.call(options.choices, key)) {\n        [].concat(argv[key]).forEach(value => {\n          if (options.choices[key].indexOf(value) === -1 && value !== undefined) {\n            invalid[key] = (invalid[key] || []).concat(value);\n          }\n        });\n      }\n    });\n    const invalidKeys = Object.keys(invalid);\n    if (!invalidKeys.length) return;\n\n    let msg = __('Invalid values:');\n\n    invalidKeys.forEach(key => {\n      msg += `\\n  ${__('Argument: %s, Given: %s, Choices: %s', key, usage.stringifiedValues(invalid[key]), usage.stringifiedValues(options.choices[key]))}`;\n    });\n    usage.fail(msg);\n  };\n\n  let checks = [];\n\n  self.check = function check(f, global) {\n    checks.push({\n      func: f,\n      global\n    });\n  };\n\n  self.customChecks = function customChecks(argv, aliases) {\n    for (let i = 0, f; (f = checks[i]) !== undefined; i++) {\n      const func = f.func;\n      let result = null;\n\n      try {\n        result = func(argv, aliases);\n      } catch (err) {\n        usage.fail(err.message ? err.message : err, err);\n        continue;\n      }\n\n      if (!result) {\n        usage.fail(__('Argument check failed: %s', func.toString()));\n      } else if (typeof result === 'string' || result instanceof Error) {\n        usage.fail(result.toString(), result);\n      }\n    }\n  };\n\n  let implied = {};\n\n  self.implies = function implies(key, value) {\n    argsert('<string|object> [array|number|string]', [key, value], arguments.length);\n\n    if (typeof key === 'object') {\n      Object.keys(key).forEach(k => {\n        self.implies(k, key[k]);\n      });\n    } else {\n      yargs.global(key);\n\n      if (!implied[key]) {\n        implied[key] = [];\n      }\n\n      if (Array.isArray(value)) {\n        value.forEach(i => self.implies(key, i));\n      } else {\n        assertNotStrictEqual(value, undefined, shim);\n        implied[key].push(value);\n      }\n    }\n  };\n\n  self.getImplied = function getImplied() {\n    return implied;\n  };\n\n  function keyExists(argv, val) {\n    const num = Number(val);\n    val = isNaN(num) ? val : num;\n\n    if (typeof val === 'number') {\n      val = argv._.length >= val;\n    } else if (val.match(/^--no-.+/)) {\n      val = val.match(/^--no-(.+)/)[1];\n      val = !argv[val];\n    } else {\n      val = argv[val];\n    }\n\n    return val;\n  }\n\n  self.implications = function implications(argv) {\n    const implyFail = [];\n    Object.keys(implied).forEach(key => {\n      const origKey = key;\n      (implied[key] || []).forEach(value => {\n        let key = origKey;\n        const origValue = value;\n        key = keyExists(argv, key);\n        value = keyExists(argv, value);\n\n        if (key && !value) {\n          implyFail.push(` ${origKey} -> ${origValue}`);\n        }\n      });\n    });\n\n    if (implyFail.length) {\n      let msg = `${__('Implications failed:')}\\n`;\n      implyFail.forEach(value => {\n        msg += value;\n      });\n      usage.fail(msg);\n    }\n  };\n\n  let conflicting = {};\n\n  self.conflicts = function conflicts(key, value) {\n    argsert('<string|object> [array|string]', [key, value], arguments.length);\n\n    if (typeof key === 'object') {\n      Object.keys(key).forEach(k => {\n        self.conflicts(k, key[k]);\n      });\n    } else {\n      yargs.global(key);\n\n      if (!conflicting[key]) {\n        conflicting[key] = [];\n      }\n\n      if (Array.isArray(value)) {\n        value.forEach(i => self.conflicts(key, i));\n      } else {\n        conflicting[key].push(value);\n      }\n    }\n  };\n\n  self.getConflicting = () => conflicting;\n\n  self.conflicting = function conflictingFn(argv) {\n    Object.keys(argv).forEach(key => {\n      if (conflicting[key]) {\n        conflicting[key].forEach(value => {\n          if (value && argv[key] !== undefined && argv[value] !== undefined) {\n            usage.fail(__('Arguments %s and %s are mutually exclusive', key, value));\n          }\n        });\n      }\n    });\n  };\n\n  self.recommendCommands = function recommendCommands(cmd, potentialCommands) {\n    const threshold = 3;\n    potentialCommands = potentialCommands.sort((a, b) => b.length - a.length);\n    let recommended = null;\n    let bestDistance = Infinity;\n\n    for (let i = 0, candidate; (candidate = potentialCommands[i]) !== undefined; i++) {\n      const d = distance(cmd, candidate);\n\n      if (d <= threshold && d < bestDistance) {\n        bestDistance = d;\n        recommended = candidate;\n      }\n    }\n\n    if (recommended) usage.fail(__('Did you mean %s?', recommended));\n  };\n\n  self.reset = function reset(localLookup) {\n    implied = objFilter(implied, k => !localLookup[k]);\n    conflicting = objFilter(conflicting, k => !localLookup[k]);\n    checks = checks.filter(c => c.global);\n    return self;\n  };\n\n  const frozens = [];\n\n  self.freeze = function freeze() {\n    frozens.push({\n      implied,\n      checks,\n      conflicting\n    });\n  };\n\n  self.unfreeze = function unfreeze() {\n    const frozen = frozens.pop();\n    assertNotStrictEqual(frozen, undefined, shim);\n    ({\n      implied,\n      checks,\n      conflicting\n    } = frozen);\n  };\n\n  return self;\n}","map":{"version":3,"sources":["C:/Users/YC/Desktop/brief6-frontend/node_modules/yargs/build/lib/validation.js"],"names":["argsert","assertNotStrictEqual","levenshtein","distance","objFilter","specialKeys","validation","yargs","usage","y18n","shim","__","__n","self","nonOptionCount","argv","demandedCommands","getDemandedCommands","positionalCount","_","length","_s","getContext","commands","min","max","minMsg","undefined","fail","replace","toString","maxMsg","required","observed","requiredArguments","demandedOptions","getDemandedOptions","missing","key","Object","keys","prototype","hasOwnProperty","call","customMsgs","msg","indexOf","push","customMsg","join","unknownArguments","aliases","positionalMap","isDefaultCommand","checkPositionals","commandKeys","getCommandInstance","getCommands","unknown","currentContext","forEach","_getParseContext","isValidAndSomeAliasIsNotNew","slice","unknownCommands","newAliases","parsed","a","limitedChoices","options","getOptions","invalid","choices","concat","value","invalidKeys","stringifiedValues","checks","check","f","global","func","customChecks","i","result","err","message","Error","implied","implies","arguments","k","Array","isArray","getImplied","keyExists","val","num","Number","isNaN","match","implications","implyFail","origKey","origValue","conflicting","conflicts","getConflicting","conflictingFn","recommendCommands","cmd","potentialCommands","threshold","sort","b","recommended","bestDistance","Infinity","candidate","d","reset","localLookup","filter","c","frozens","freeze","unfreeze","frozen","pop"],"mappings":"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","sourcesContent":["import { argsert } from './argsert.js';\nimport { assertNotStrictEqual, } from './typings/common-types.js';\nimport { levenshtein as distance } from './utils/levenshtein.js';\nimport { objFilter } from './utils/obj-filter.js';\nconst specialKeys = ['$0', '--', '_'];\nexport function validation(yargs, usage, y18n, shim) {\n    const __ = y18n.__;\n    const __n = y18n.__n;\n    const self = {};\n    self.nonOptionCount = function nonOptionCount(argv) {\n        const demandedCommands = yargs.getDemandedCommands();\n        const positionalCount = argv._.length + (argv['--'] ? argv['--'].length : 0);\n        const _s = positionalCount - yargs.getContext().commands.length;\n        if (demandedCommands._ &&\n            (_s < demandedCommands._.min || _s > demandedCommands._.max)) {\n            if (_s < demandedCommands._.min) {\n                if (demandedCommands._.minMsg !== undefined) {\n                    usage.fail(demandedCommands._.minMsg\n                        ? demandedCommands._.minMsg\n                            .replace(/\\$0/g, _s.toString())\n                            .replace(/\\$1/, demandedCommands._.min.toString())\n                        : null);\n                }\n                else {\n                    usage.fail(__n('Not enough non-option arguments: got %s, need at least %s', 'Not enough non-option arguments: got %s, need at least %s', _s, _s.toString(), demandedCommands._.min.toString()));\n                }\n            }\n            else if (_s > demandedCommands._.max) {\n                if (demandedCommands._.maxMsg !== undefined) {\n                    usage.fail(demandedCommands._.maxMsg\n                        ? demandedCommands._.maxMsg\n                            .replace(/\\$0/g, _s.toString())\n                            .replace(/\\$1/, demandedCommands._.max.toString())\n                        : null);\n                }\n                else {\n                    usage.fail(__n('Too many non-option arguments: got %s, maximum of %s', 'Too many non-option arguments: got %s, maximum of %s', _s, _s.toString(), demandedCommands._.max.toString()));\n                }\n            }\n        }\n    };\n    self.positionalCount = function positionalCount(required, observed) {\n        if (observed < required) {\n            usage.fail(__n('Not enough non-option arguments: got %s, need at least %s', 'Not enough non-option arguments: got %s, need at least %s', observed, observed + '', required + ''));\n        }\n    };\n    self.requiredArguments = function requiredArguments(argv) {\n        const demandedOptions = yargs.getDemandedOptions();\n        let missing = null;\n        for (const key of Object.keys(demandedOptions)) {\n            if (!Object.prototype.hasOwnProperty.call(argv, key) ||\n                typeof argv[key] === 'undefined') {\n                missing = missing || {};\n                missing[key] = demandedOptions[key];\n            }\n        }\n        if (missing) {\n            const customMsgs = [];\n            for (const key of Object.keys(missing)) {\n                const msg = missing[key];\n                if (msg && customMsgs.indexOf(msg) < 0) {\n                    customMsgs.push(msg);\n                }\n            }\n            const customMsg = customMsgs.length ? `\\n${customMsgs.join('\\n')}` : '';\n            usage.fail(__n('Missing required argument: %s', 'Missing required arguments: %s', Object.keys(missing).length, Object.keys(missing).join(', ') + customMsg));\n        }\n    };\n    self.unknownArguments = function unknownArguments(argv, aliases, positionalMap, isDefaultCommand, checkPositionals = true) {\n        const commandKeys = yargs.getCommandInstance().getCommands();\n        const unknown = [];\n        const currentContext = yargs.getContext();\n        Object.keys(argv).forEach(key => {\n            if (specialKeys.indexOf(key) === -1 &&\n                !Object.prototype.hasOwnProperty.call(positionalMap, key) &&\n                !Object.prototype.hasOwnProperty.call(yargs._getParseContext(), key) &&\n                !self.isValidAndSomeAliasIsNotNew(key, aliases)) {\n                unknown.push(key);\n            }\n        });\n        if (checkPositionals &&\n            (currentContext.commands.length > 0 ||\n                commandKeys.length > 0 ||\n                isDefaultCommand)) {\n            argv._.slice(currentContext.commands.length).forEach(key => {\n                if (commandKeys.indexOf('' + key) === -1) {\n                    unknown.push('' + key);\n                }\n            });\n        }\n        if (unknown.length > 0) {\n            usage.fail(__n('Unknown argument: %s', 'Unknown arguments: %s', unknown.length, unknown.join(', ')));\n        }\n    };\n    self.unknownCommands = function unknownCommands(argv) {\n        const commandKeys = yargs.getCommandInstance().getCommands();\n        const unknown = [];\n        const currentContext = yargs.getContext();\n        if (currentContext.commands.length > 0 || commandKeys.length > 0) {\n            argv._.slice(currentContext.commands.length).forEach(key => {\n                if (commandKeys.indexOf('' + key) === -1) {\n                    unknown.push('' + key);\n                }\n            });\n        }\n        if (unknown.length > 0) {\n            usage.fail(__n('Unknown command: %s', 'Unknown commands: %s', unknown.length, unknown.join(', ')));\n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n    self.isValidAndSomeAliasIsNotNew = function isValidAndSomeAliasIsNotNew(key, aliases) {\n        if (!Object.prototype.hasOwnProperty.call(aliases, key)) {\n            return false;\n        }\n        const newAliases = yargs.parsed.newAliases;\n        for (const a of [key, ...aliases[key]]) {\n            if (!Object.prototype.hasOwnProperty.call(newAliases, a) ||\n                !newAliases[key]) {\n                return true;\n            }\n        }\n        return false;\n    };\n    self.limitedChoices = function limitedChoices(argv) {\n        const options = yargs.getOptions();\n        const invalid = {};\n        if (!Object.keys(options.choices).length)\n            return;\n        Object.keys(argv).forEach(key => {\n            if (specialKeys.indexOf(key) === -1 &&\n                Object.prototype.hasOwnProperty.call(options.choices, key)) {\n                [].concat(argv[key]).forEach(value => {\n                    if (options.choices[key].indexOf(value) === -1 &&\n                        value !== undefined) {\n                        invalid[key] = (invalid[key] || []).concat(value);\n                    }\n                });\n            }\n        });\n        const invalidKeys = Object.keys(invalid);\n        if (!invalidKeys.length)\n            return;\n        let msg = __('Invalid values:');\n        invalidKeys.forEach(key => {\n            msg += `\\n  ${__('Argument: %s, Given: %s, Choices: %s', key, usage.stringifiedValues(invalid[key]), usage.stringifiedValues(options.choices[key]))}`;\n        });\n        usage.fail(msg);\n    };\n    let checks = [];\n    self.check = function check(f, global) {\n        checks.push({\n            func: f,\n            global,\n        });\n    };\n    self.customChecks = function customChecks(argv, aliases) {\n        for (let i = 0, f; (f = checks[i]) !== undefined; i++) {\n            const func = f.func;\n            let result = null;\n            try {\n                result = func(argv, aliases);\n            }\n            catch (err) {\n                usage.fail(err.message ? err.message : err, err);\n                continue;\n            }\n            if (!result) {\n                usage.fail(__('Argument check failed: %s', func.toString()));\n            }\n            else if (typeof result === 'string' || result instanceof Error) {\n                usage.fail(result.toString(), result);\n            }\n        }\n    };\n    let implied = {};\n    self.implies = function implies(key, value) {\n        argsert('<string|object> [array|number|string]', [key, value], arguments.length);\n        if (typeof key === 'object') {\n            Object.keys(key).forEach(k => {\n                self.implies(k, key[k]);\n            });\n        }\n        else {\n            yargs.global(key);\n            if (!implied[key]) {\n                implied[key] = [];\n            }\n            if (Array.isArray(value)) {\n                value.forEach(i => self.implies(key, i));\n            }\n            else {\n                assertNotStrictEqual(value, undefined, shim);\n                implied[key].push(value);\n            }\n        }\n    };\n    self.getImplied = function getImplied() {\n        return implied;\n    };\n    function keyExists(argv, val) {\n        const num = Number(val);\n        val = isNaN(num) ? val : num;\n        if (typeof val === 'number') {\n            val = argv._.length >= val;\n        }\n        else if (val.match(/^--no-.+/)) {\n            val = val.match(/^--no-(.+)/)[1];\n            val = !argv[val];\n        }\n        else {\n            val = argv[val];\n        }\n        return val;\n    }\n    self.implications = function implications(argv) {\n        const implyFail = [];\n        Object.keys(implied).forEach(key => {\n            const origKey = key;\n            (implied[key] || []).forEach(value => {\n                let key = origKey;\n                const origValue = value;\n                key = keyExists(argv, key);\n                value = keyExists(argv, value);\n                if (key && !value) {\n                    implyFail.push(` ${origKey} -> ${origValue}`);\n                }\n            });\n        });\n        if (implyFail.length) {\n            let msg = `${__('Implications failed:')}\\n`;\n            implyFail.forEach(value => {\n                msg += value;\n            });\n            usage.fail(msg);\n        }\n    };\n    let conflicting = {};\n    self.conflicts = function conflicts(key, value) {\n        argsert('<string|object> [array|string]', [key, value], arguments.length);\n        if (typeof key === 'object') {\n            Object.keys(key).forEach(k => {\n                self.conflicts(k, key[k]);\n            });\n        }\n        else {\n            yargs.global(key);\n            if (!conflicting[key]) {\n                conflicting[key] = [];\n            }\n            if (Array.isArray(value)) {\n                value.forEach(i => self.conflicts(key, i));\n            }\n            else {\n                conflicting[key].push(value);\n            }\n        }\n    };\n    self.getConflicting = () => conflicting;\n    self.conflicting = function conflictingFn(argv) {\n        Object.keys(argv).forEach(key => {\n            if (conflicting[key]) {\n                conflicting[key].forEach(value => {\n                    if (value && argv[key] !== undefined && argv[value] !== undefined) {\n                        usage.fail(__('Arguments %s and %s are mutually exclusive', key, value));\n                    }\n                });\n            }\n        });\n    };\n    self.recommendCommands = function recommendCommands(cmd, potentialCommands) {\n        const threshold = 3;\n        potentialCommands = potentialCommands.sort((a, b) => b.length - a.length);\n        let recommended = null;\n        let bestDistance = Infinity;\n        for (let i = 0, candidate; (candidate = potentialCommands[i]) !== undefined; i++) {\n            const d = distance(cmd, candidate);\n            if (d <= threshold && d < bestDistance) {\n                bestDistance = d;\n                recommended = candidate;\n            }\n        }\n        if (recommended)\n            usage.fail(__('Did you mean %s?', recommended));\n    };\n    self.reset = function reset(localLookup) {\n        implied = objFilter(implied, k => !localLookup[k]);\n        conflicting = objFilter(conflicting, k => !localLookup[k]);\n        checks = checks.filter(c => c.global);\n        return self;\n    };\n    const frozens = [];\n    self.freeze = function freeze() {\n        frozens.push({\n            implied,\n            checks,\n            conflicting,\n        });\n    };\n    self.unfreeze = function unfreeze() {\n        const frozen = frozens.pop();\n        assertNotStrictEqual(frozen, undefined, shim);\n        ({ implied, checks, conflicting } = frozen);\n    };\n    return self;\n}\n"]},"metadata":{},"sourceType":"module"}